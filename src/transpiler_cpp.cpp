#include "transpiler_cpp.h"
#include <iostream>
#include <array>

// ==================================
// Entry Point
// ==================================
std::string CPPTranspiler::transpile(const std::shared_ptr<ASTNode>& ast) {
    std::string output;
    output += "// Generated by Mammuth\n";
    output += "#include <iostream>\n";
    output+="#include <vector>\n";
    output += "#include <array>\n";
    output += "#include <cmath>\n\n";
    output += "#include \"utf8.h\"\n";
    output += "#include \"random.h\"\n\n";

    // Separa funzioni da statements
    std::string functions = "";
    std::string mainBody = "";

    auto body = ast->children[0];  // Body del Program
    for (auto& child : body->children) {
        if (child->type == "FunctionDef") {
            functions += generateCode(child);
        } else {
            mainBody += "    " + generateCode(child);
        }
    }

    output += functions;
    output += "int main() {\n";
    output += mainBody;
    output += "    return 0;\n}\n";
    return output;
}

// ==================================
// Core Dispatcher
// ==================================
std::string CPPTranspiler::generateCode(const std::shared_ptr<ASTNode>& node) {
    if (!node) return "";

    if (node->type == "Program") {
        // Processa body
        return generateCode(node->children[0]);

    } else if (node->type == "Body") {
        std::string code;
        for (auto& child : node->children) {
            code += "    " + generateCode(child);
        }
        return code;

    } else if (node->type == "Echo") {
        return generateEcho(node);

    } else if (node->type == "Literal") {
        return generateLiteral(node);

    } else if (node->type == "VarDecl") {
        return generateVarDecl(node);
    }else if (node->type == "Identifier") {
        return generateIdentifier(node);
    }else if (node->type == "BinaryOp") {
        return generateBinaryOp(node);
    } else if (node->type == "IfExpr") {
        return generateIfExpression(node);
    } else if (node->type == "ExprStmt") {
        return generateCode(node->children[0]);
    }else if (node->type == "While") {
        return generateWhileLoop(node);
    }else if (node->type == "Assign") {
        return generateAssignment(node);
    }else if (node->type == "ForIn") {
        return generateForLoop(node);
    }else if (node->type == "ArrayDecl") {
        return generateArrayDecl(node);
    } else if (node->type == "ArrayInit") {
        return generateArrayInit(node);
    }else if (node->type == "CommaList") {
        return generateCommaList(node);
    } else if (node->type == "FunctionDef") {
        return generateFunctionDef(node);
    } else if (node->type == "Call") {
        return generateFunctionCall(node);
    }else if (node->type == "UnaryOp") {
        return generateUnaryOp(node);
    }else if (node->type == "ArrayAccess") {
        return generateArrayAccess(node);
    }else if (node->type == "CondChain") {
        return generateCondChain(node);
    }else if (node->type == "Filter") {
        return generateFilter(node);
    }
    else {
        throw std::runtime_error("Tipo non gestito: " + node->type);
    }
}

// ==================================
// Generators per tipo di nodo
// ==================================

// Literals & Basic
std::string CPPTranspiler::generateLiteral(const std::shared_ptr<ASTNode>& node) {
    if (node->tokenType == TokenType::NUMBER_INT) {
        return node->value;
    } else if (node->tokenType == TokenType::NUMBER_DBL) {
        return node->value;
    } else if (node->tokenType == TokenType::STRING) {
        return "\"" + node->value + "\"";
    }
    return "";
}

std::string CPPTranspiler::generateIdentifier(const std::shared_ptr<ASTNode>& node) {
    return node->value;  // Nome variabile
}

// Declarations
std::string CPPTranspiler::generateVarDecl(const std::shared_ptr<ASTNode>& node) {
    bool isFixed = node->extra.count("fixed") &&
                   node->extra.at("fixed") == "true";

    std::string type = mapMammuthTypeToCpp(node->extra.at("type"));
    std::string name = node->value;
    this->varTypes[name] = type;
    std::string value = generateCode(node->children[0]);

    std::string prefix = isFixed ? "const " : "";

    return prefix + type + " " + name + " = " + value + ";\n";
}

std::string CPPTranspiler::generateFunctionDef(const std::shared_ptr<ASTNode>& node) {
    std::string name = node->value;
    std::string returnType = mapMammuthTypeToCpp(node->extra.at("returnType"));

    // Parametri
    std::string params = "";
    for (size_t i = 0; i < node->children.size() - 1; i++) {
        auto param = node->children[i];
        if (i > 0) params += ", ";
        std::string ptype = mapMammuthTypeToCpp(param->extra.at("paramType"));
        params += ptype + " " + param->value;
    }
    // Nel body, ultima espressione diventa return
    std::string body = "    return " + generateCode(node->children.back()->children[0]) + ";\n";
    return returnType + " " + name + "(" + params + ") {\n" + body + "}\n\n";
}

std::string CPPTranspiler::generateFunctionCall(const std::shared_ptr<ASTNode>& node) {
    std::string code="";
    std::string name = node->value;

    // Builtin mappings
    if (name == "str") name = "std::to_string";
    if (name == "len") name = "size";  // arr.size()
    if (name == "toInt") name = "std::stoi";

    if (name == "randInt") {
        // randInt(min, max) → (rand() % (max - min + 1)) + min
        std::string min = generateCode(node->children[0]);
        std::string max = generateCode(node->children[1]);
        return "Random::randInt(" +min+","+max+")";
    }
    if (name == "randDouble") {
        return "Random::randDouble()";
    }
    if (name == "input") {
        return "([&]() { std::string s; std::getline(std::cin, s); return s; })()";
    }
    // Per len, usa .size()
    if (node->value == "len") {
        return generateCode(node->children[0]) + ".size()";
    }

    std::string args = "";
    for (size_t i = 0; i < node->children.size(); i++) {
        if (i > 0) args += ", ";
        args += generateCode(node->children[i]);
    }

    return name + "(" + args + ")";
}

// Expressions
std::string CPPTranspiler::generateBinaryOp(const std::shared_ptr<ASTNode>& node) {
    std::string left = generateCode(node->children[0]);
    std::string right = generateCode(node->children[1]);
    std::string op = node->value;

    if (op == "$") {
        return "(std::string(" + left + ") + " + right + ")";
    }

    if (op == "**") {
        return "std::pow(" + left + ", " + right + ")";
    }

    return "(" + left + " " + op + " " + right + ")";
}

std::string CPPTranspiler::generateUnaryOp(const std::shared_ptr<ASTNode>& node) {
    std::string op = node->value;
    std::string expr = generateCode(node->children[0]);

    if (op == "!") return "(!" + expr + ")";
    if (op == "-") return "(-" + expr + ")";

    return "(" + op + expr + ")";
}

std::string CPPTranspiler::generateIfExpression(const std::shared_ptr<ASTNode>& node) {
    bool isMultiline = node->extra.count("multiline") &&
                       node->extra.at("multiline") == "true";

    // Multi-line → if statement
    if (isMultiline) {
        return generateIfStatement(node);
    }

    // Inline → ternary
    std::string cond = generateCode(node->children[0]);
    std::string thenBranch = generateCode(node->children[1]);
    std::string elseBranch = node->children.size() > 2 ?
        generateCode(node->children[2]) : "0";

    return "(" + cond + " ? " + thenBranch + " : " + elseBranch + ")";
}

std::string CPPTranspiler::generateIfStatement(const std::shared_ptr<ASTNode>& node) {
    // node->children: [cond, thenBody, elifCond1, elifBody1, ..., elseBody?]

    std::string code = "if (" + generateCode(node->children[0]) + ") {\n";
    code += generateCode(node->children[1]); // then body
    code += "    }";

    int elifCount = std::stoi(node->extra.at("elifCount"));
    bool hasElse = node->extra.at("hasElse") == "true";

    // elif branches
    for (int i = 0; i < elifCount; i++) {
        code += " else if (" + generateCode(node->children[2 + i*2]) + ") {\n";
        code += generateCode(node->children[2 + i*2 + 1]);
        code += "    }";
    }

    // else branch
    if (hasElse) {
        code += " else {\n";
        code += generateCode(node->children.back());
        code += "    }";
    }

    code += "\n";
    return code;
}

// Statements
std::string CPPTranspiler::generateEcho(const std::shared_ptr<ASTNode>& node) {
    std::string code = "std::cout << ";
    code += generateCode(node->children[0]);
    code += " << std::endl;\n";
    return code;
}

std::string CPPTranspiler::generateAssignment(const std::shared_ptr<ASTNode>& node) {
    // Check TIPO senza generare codice
    if (node->children.size() > 0 &&
        node->children[0]->type == "ArrayAccess") {

        std::string arrayAccess = generateCode(node->children[0]);
        std::string value = generateCode(node->children[1]);
        return arrayAccess + " = " + value + ";\n";
    }

    // Assignment normale
    std::string name = node->value;
    std::string value = generateCode(node->children[1]);
    return name + " = " + value + ";\n";
}

// Control Flow
std::string CPPTranspiler::generateWhileLoop(const std::shared_ptr<ASTNode>& node) {
    std::string cond = generateCode(node->children[0]);
    std::string body = generateCode(node->children[1]);

    return "while (" + cond + ") {\n" + body + "    }\n";
}

std::string CPPTranspiler::generateForLoop(const std::shared_ptr<ASTNode>& node) {
    // node->value = variabile iteratore
    // node->children[0] = array su cui iterare
    // node->children[1] = body

    std::string var = node->value;
    std::string array = generateCode(node->children[0]);
    std::string body = generateCode(node->children[1]);

    return "for (auto " + var + " : " + array + ") {\n" + body + "    }\n";
}

// Advanced
std::string CPPTranspiler::generateCondChain(const std::shared_ptr<ASTNode>& node) {
    // CondChain diventa ternary nidificato
    std::string result = "";
    bool hasFallback = node->extra.at("hasFallback") == "1";
    size_t limit = hasFallback ? node->children.size() - 1 : node->children.size();

    for (size_t i = 0; i < limit; i++) {
        auto sc = node->children[i];  // SimpleCond
        std::string cond = generateCode(sc->children[0]);
        std::string expr = generateCode(sc->children[1]);

        result += "(" + cond + " ? " + expr + " : ";
    }

    if (hasFallback) {
        result += generateCode(node->children.back());
    } else {
        result += "0";
    }

    for (size_t i = 0; i < limit; i++) result += ")";

    return result;
}

std::string CPPTranspiler::generateFilter(const std::shared_ptr<ASTNode>& node) {
    std::string arrayExpr = generateCode(node->children[0]);

    // Sostituisci 'x' con lambda param nella condizione
    std::string cond = generateCode(node->children[1]);
    // Sostituisci identificatore 'x' con parametro lambda

    return "([&]() { std::vector<int> result; for (auto x : " + arrayExpr +
           ") { if (" + cond + ") result.push_back(x); } return result; })()";
}

std::string CPPTranspiler::generateCommaList(const std::shared_ptr<ASTNode>& node) {
    std::string result = "";
    for (size_t i = 0; i < node->children.size(); i++) {
        if (i > 0) result += ", ";
        result += generateCode(node->children[i]);
    }
    return result;
}

// Array
std::string CPPTranspiler::generateArrayInit(const std::shared_ptr<ASTNode>& node) {
    // Se contiene un solo ArrayAccess, non wrappare con graffe
    if (node->children.size() == 1 &&
        node->children[0]->type == "ArrayAccess") {
        return generateCode(node->children[0]);
    }

    // Normale array literal
    std::string values = "{";
    for (size_t i = 0; i < node->children.size(); i++) {
        if (i > 0) values += ", ";
        values += generateCode(node->children[i]);
    }
    values += "}";
    return values;
}

std::string CPPTranspiler::generateArrayDecl(const std::shared_ptr<ASTNode>& node) {
    std::string type = mapMammuthTypeToCpp(node->extra.at("type"));
    std::string name = node->value;
    bool isDynamic = node->extra.count("dynamic") &&
                     node->extra.at("dynamic") == "true";
    std::string values = generateCode(node->children[0]);
    bool isSlice = node->children[0]->type == "ArrayInit" &&
               node->children[0]->children.size() > 0 &&
               node->children[0]->children[0]->type == "ArrayAccess" &&
               node->children[0]->children[0]->children.size() > 0 &&
               node->children[0]->children[0]->children.back()->type == "RangeExpr";

    // Array slicing returns dynamic array (std::vector)
    if (isDynamic || isSlice) {
        return "std::vector<" + type + "> " + name + " = " + values + ";\n";
    } else {
        // Array immutabile - std::array con size
        size_t size = countArraySize(node->children[0]);
        return "std::array<" + type + ", " + std::to_string(size) +
               "> " + name + " = " + values + ";\n";
    }
}

size_t CPPTranspiler::countArraySize(const std::shared_ptr<ASTNode>& node) {
    if (node->type == "ArrayInit" && !node->children.empty()) {
        auto commaList = node->children[0];
        return commaList->children.size();
    }
    return node->children.size();
}

std::string CPPTranspiler::generateArrayAccess(const std::shared_ptr<ASTNode>& node) {
    std::string array = node->value.empty() ?
        generateCode(node->children[0]) : node->value;
    size_t idxPos = node->value.empty() ? 1 : 0;
    auto indexNode = node->children[idxPos];

    if (indexNode->type == "RangeExpr") {
        return generateSlice(array, indexNode);
    }

    std::string index = generateCode(indexNode);
    return array + "[" + index + "]";
}

std::string CPPTranspiler::generateSlice(const std::string& array, const std::shared_ptr<ASTNode>& rangeNode) {
    std::string start = rangeNode->children.size() > 0 && rangeNode->children[0] ?
        generateCode(rangeNode->children[0]) : "0";
    std::string end = rangeNode->children.size() > 1 && rangeNode->children[1] ?
        generateCode(rangeNode->children[1]) : array + ".size()";

    // Controlla se array è una var string
    bool isString = varTypes.count(array) && varTypes[array] == "std::string";

    if (isString) {
        return "utf8SliceRange(" + array + ", " + start + ", " + end + ")";
    } else {
        return "std::vector(" + array + ".begin() + " + start + ", " +
            array + ".begin() + " + end + ")";
    }
}

// ==================================
// Utilities
// ==================================
std::string CPPTranspiler::indent(int level){
    return "";
}

std::string CPPTranspiler::mapMammuthTypeToCpp(const std::string& mammuthType) {
    if (mammuthType == "int") return "int";
    if (mammuthType == "double") return "double";
    if (mammuthType == "string") return "std::string";
    return mammuthType;
}
